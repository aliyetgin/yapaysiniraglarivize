\documentclass[11pt]{article}

% Language setting
\usepackage[turkish]{babel}
\usepackage{pythonhighlight}

\usepackage[a4paper,top=2cm,bottom=2cm,left=2cm,right=2cm,marginparwidth=2cm]{geometry}

% Useful packages
\usepackage{amsmath}
\usepackage{graphicx}
\usepackage[colorlinks=true, allcolors=blue]{hyperref}
\usepackage{verbatim}
\usepackage{fancyhdr} % for header and footer
\usepackage{titlesec}
\usepackage{parskip}

\setlength{\parindent}{0pt}

\titleformat{\subsection}[runin]{\bfseries}{\thesubsection}{1em}{}

\pagestyle{fancy} % activate the custom header/footer

% define the header/footer contents
\lhead{\small{23BLM-4014 Yapay Sinir Ağları Ara Sınav Soru ve Cevap Kağıdı}}
\rhead{\small{Dr. Ulya Bayram}}
\lfoot{}
\rfoot{}

% remove header/footer on first page
\fancypagestyle{firstpage}{
  \lhead{}
  \rhead{}
  \lfoot{}
  \rfoot{\thepage}
}
 

\title{Çanakkale Onsekiz Mart Üniversitesi, Mühendislik Fakültesi, Bilgisayar Mühendisliği Akademik Dönem 2022-2023\\
Ders: BLM-4014 Yapay Sinir Ağları/Bahar Dönemi\\ 
ARA SINAV SORU VE CEVAP KAĞIDI\\
Dersi Veren Öğretim Elemanı: Dr. Öğretim Üyesi Ulya Bayram}
\author{%
\begin{minipage}{\textwidth}
\raggedright
Öğrenci Adı Soyadı:Ali Yetgin\newline
Öğrenci No: 210401006
\end{minipage}%
}

\date{14 Nisan 2023}

\begin{document}
\maketitle

\vspace{-.5in}
\section*{Açıklamalar:}
\begin{itemize}
    \item Vizeyi çözüp, üzerinde aynı sorular, sizin cevaplar ve sonuçlar olan versiyonunu bu formatta PDF olarak, Teams üzerinden açtığım assignment kısmına yüklemeniz gerekiyor. Bu bahsi geçen PDF'i oluşturmak için LaTeX kullandıysanız, tex dosyasının da yer aldığı Github linkini de ödevin en başına (aşağı url olarak) eklerseniz bonus 5 Puan! (Tavsiye: Overleaf)
    \item Çözümlerde ya da çözümlerin kontrolünü yapmada internetten faydalanmak, ChatGPT gibi servisleri kullanmak serbest. Fakat, herkesin çözümü kendi emeğinden oluşmak zorunda. Çözümlerinizi, cevaplarınızı aşağıda belirttiğim tarih ve saate kadar kimseyle paylaşmayınız. 
    \item Kopyayı önlemek için Github repository'lerinizin hiçbirini \textbf{14 Nisan 2023, saat 15:00'a kadar halka açık (public) yapmayınız!} (Assignment son yükleme saati 13:00 ama internet bağlantısı sorunları olabilir diye en fazla ekstra 2 saat daha vaktiniz var. \textbf{Fakat 13:00 - 15:00 arası yüklemelerden -5 puan!}
    \item Ek puan almak için sağlayacağınız tüm Github repository'lerini \textbf{en geç 15 Nisan 2023 15:00'da halka açık (public) yapmış olun linklerden puan alabilmek için!}
    \item \textbf{14 Nisan 2023, saat 15:00'dan sonra gönderilen vizeler değerlendirilmeye alınmayacak, vize notu olarak 0 (sıfır) verilecektir!} Son anda internet bağlantısı gibi sebeplerden sıfır almayı önlemek için assignment kısmından ara ara çözümlerinizi yükleyebilirsiniz yedekleme için. Verilen son tarih/saatte (14 Nisan 2023, saat 15:00) sistemdeki en son yüklü PDF geçerli olacak.
    \item Çözümlerin ve kodların size ait ve özgün olup olmadığını kontrol eden bir algoritma kullanılacaktır. Kopya çektiği belirlenen vizeler otomatikman 0 (sıfır) alacaktır. Bu nedenle çözümlerinizi ve kodlarınızı yukarıda sağladığım gün ve saatlere kadar kimseyle paylaşmayınız.
    \item Bu vizeden alınabilecek en yüksek not 100'dür. Toplam aldığınız puan 100'ü geçerse, aldığınız not 100'e sabitlenecektir.
    \item LaTeX kullanarak PDF oluşturanlar öz geçmişlerine LaTeX bildiklerini de eklemeyi unutmasınlar :)
    \item Bu vizedeki soruların çözümleri ve tex dosyası için istediğiniz kadar sayıda Github repository'si oluşturabilirsiniz. Sadece yukarıda belirttiğim tarihlerde (14 Nisan 2023 saat 15:00 ile 15 Nisan 2023 saat 15:00 arasında) public yapmayı/halka açmayı ve Github profilinizi de öz geçmişinize eklemeyi unutmayın :)
    \item Bilgisayarınıza hiçbir program kurmadan, Overleaf, Google Colab, Kaggle gibi ortamlar üzerinden bu vizeyi tamamlamanız mümkün. İyi çalışmalar!!
\end{itemize}

(Ekstra 5 puan) \url{https://github.com/aliyetgin/yapaysiniraglarivize/blob/main/vize.tex}

\newpage
\section{(Toplam 10 Puan) Hopfield Networks:}

\subsection{(2 Puan)} \textbf{ChatGPT’ye size Hopfield Network’ler ile ilgili detaylı bilgi vermesini isteyin. Sorduğunuz soruyu, ChatGPT'nin çıkartığı cevabı aşağı koyun. Bu cevapta anlamadığınız terimleri de ChatGPT’ye sorup, sorduğunuz soruları ve ChatGPT’nin verdiği cevapları da sırayla aşağı koyun.}

Soru: Bana Hopfield Network’le ilgili detaylı bilgi verir misin?

Cevap: Hopfield ağı, sınırlı kapasiteli bir yapay sinir ağıdır. Nöronlar, tüm düğümlerin birbirleriyle bağlantılı olduğu bir graf yapısında düzenlenir. Ağ, asenkron bir şekilde çalışır ve nöronların durumlarını sigmoid fonksiyonu kullanarak hesaplar.

Hopfield ağları, hafızayı saklamak, hatırlamak ve yeniden çağırmak için kullanılır. Öğrenme sırasında, Hopfield ağı, veri kümesindeki öğeler arasındaki benzerliklere dayalı olarak nöron bağlantılarını öğrenir. Bu sayede, Hopfield ağı öğrenilen bir deseni hatırlayabilir ve bozukluğu olan bir desene benzer bir desenle eşleştirebilir.

Ayrıca, Hopfield ağları, aynı zamanda birçok uygulama için de kullanılabilir. Örneğin, veri sıkıştırma, veri kurtarma ve kalıpların tanınması işlemlerinde kullanılabilirler.

Hopfield ağı, aşağıdaki özelliklere sahiptir:

    - Sınırlı kapasiteli: Hopfield ağı, sınırlı sayıda deseni hatırlayabilir. 
    Bu kapasite, ağın boyutuna ve desenlerin karmaşıklığına bağlıdır.\newline
    - Enerji fonksiyonu: Hopfield ağı, bir enerji fonksiyonu kullanır. Bu fonksiyon, ağın mevcut durumunun bir ölçüsüdür ve hatırlama işleminde kullanılır.\newline
    - Asenkron çalışma: Hopfield ağı, nöronları asenkron bir şekilde hesaplar. Bu, ağın daha hızlı çalışmasına ve daha az bellek kullanmasına olanak tanır.\newline
   - Geri besleme: Hopfield ağı, geri beslemeli bir yapıya sahiptir. Bu yapı, ağın hatırlama işlemi için önemlidir.

Hopfield ağları, öğrenme sırasında Hebb kuralını kullanırlar. Bu kurala göre, eşzamanlı olarak ateşleyen nöronlar arasındaki bağlantılar güçlenir. Bu sayede, Hopfield ağı, öğrenilen desenleri hatırlayabilir ve bozukluğu olan bir desene benzer bir desenle eşleştirebilir.

Ancak, Hopfield ağları sadece basit desenlerin hatırlanması için kullanılabilir. Daha karmaşık desenlerin hatırlanması için daha büyük ve daha karmaşık ağlar gereklidir.

Sorular:\newline
1-Enerji fonksiyonu nedir ?\newline
Cevap: Enerji fonksiyonu, fiziksel sistemlerin enerji durumunu ifade eden matematiksel bir fonksiyondur. Bu fonksiyon, sistemin içinde bulunduğu durumun enerjisini hesaplar.

Yapay zeka ve makine öğrenmesi gibi alanlarda, enerji fonksiyonu, bir modelin öğrenme hedeflerini ifade etmek için kullanılabilir. Bu amaçla, enerji fonksiyonu, modelin öğrenmek istediği hedeflerin bir ölçüsü olarak kullanılabilir.

Örneğin, Hopfield ağı gibi bazı yapay sinir ağı modelleri, bir enerji fonksiyonu kullanır. Bu ağlar, bir veri örüntüsünü öğrenmek ve daha sonra benzer örüntüleri tanımak için kullanılır. Bu süreçte, enerji fonksiyonu, ağın öğrenme ilerlemesini ölçmek ve doğru sonuçları üretmek için kullanılır.

Enerji fonksiyonu, birçok farklı matematiksel formda ifade edilebilir. Bu formlar, spesifik bir problem için en uygun olanı seçmek için kullanılır. Enerji fonksiyonu, sistemin mevcut durumunu belirleyen değişkenlerin bir fonksiyonu olarak ifade edilir ve bu değişkenlerin değerlerine göre farklı enerji seviyeleri atar. Enerji fonksiyonunun en düşük enerjili durumu, sistemin en istikrarlı durumunu ifade eder.

2-Hebb kuralı nedir ?\newline
Cevap: Hebb kuralı, sinir biliminde kullanılan bir öğrenme kuralıdır. Bu kural, bir nöronun başka bir nöronla bağlantısının gücünü değiştiren bir öğrenme kuralıdır. Kısaca, "birlikte ateşleyen hücreler birlikte telaffuz edilir" şeklinde özetlenebilir.

Hebb kuralı, "eşzamanlı ateşleme, birlikte ateşleme" prensibine dayanır. Bu kurala göre, iki nöron eşzamanlı olarak ateşlenirse, bağlantılarını güçlendirmeleri beklenir. Bunun sebebi, bir nöronun diğerini ateşlediği zaman, sinaptik bağlantının güçlenmesiyle iki nöronun birbirine daha sıkı bağlanmasıdır.

Örneğin, bir nöron X, bir diğeri Y ile bağlantılı olsun. Nöron X, nöron Y'yi ateşlediğinde, Hebb kuralına göre X nöronunun Y nöronuyla olan bağlantısı güçlenir. Bu durum, nöron X'in tekrar ateşlediğinde, Y nöronunun ateşlemesine daha yatkın hale gelmesine yol açar.

Hebb kuralı, beyindeki öğrenme sürecinin açıklanmasına yardımcı olur. Bu kural, beyindeki sinir ağları arasındaki bağlantıların nasıl şekillendiği ve nasıl öğrenme süreçleri gerçekleştirdiği konusunda önemli bir ipucu verir. Yapay sinir ağları ve derin öğrenme modellerinde de Hebb kuralı, nöronların bağlantılarını güçlendirmek için kullanılan bir öğrenme kuralıdır.

3-Geri beslemeli yapı(yapay sinir ağları) nedir??\newline
Cevap: Geri beslemeli yapılı yapay sinir ağları, bir çıktının aynı zamanda sistemin girdilerine de etki ettiği yapay sinir ağlarıdır. Bu yapıda, ağın çıktısı bir geri besleme döngüsü aracılığıyla tekrar ağın girdisine yönlendirilir. Bu geri besleme döngüsü, ağın davranışını önceden belirlemek için kullanılabilir.

Geri beslemeli yapılı yapay sinir ağları, birçok farklı alanda kullanılır. Örneğin, geri beslemeli yapılı yapay sinir ağları, kontrol sistemlerinde kullanılabilir. Bu yapay sinir ağları, geri beslemeli bir kontrol döngüsü aracılığıyla sistemin davranışını ayarlamak için kullanılır.

Ayrıca, geri beslemeli yapılı yapay sinir ağları, sıralı verileri işlemek için de kullanılabilir. Örneğin, doğal dil işleme ve konuşma tanıma sistemlerinde geri beslemeli yapılı yapay sinir ağları kullanılır. Bu yapay sinir ağları, bir önceki adımdan gelen bilgileri kullanarak gelecekteki adımlar için tahminler yapabilirler.

Geri beslemeli yapılı yapay sinir ağları, öğrenme sürecinde de kullanılabilirler. Bu yapay sinir ağları, geri beslemeli bağlantıları kullanarak önceki örneklerden öğrenilen bilgileri yeni örnekler için kullanabilirler. Bu özellikleri nedeniyle, geri beslemeli yapılı yapay sinir ağları, karmaşık ve dinamik problemler için etkili bir araçtır.

\subsection{(8 Puan)} \textbf{ChatGPT’nin açıklamalarından ne anladığınızı buraya kendi kelimelerinizle özetleyin. Örneğin ``Hopfield Network nedir? Ne işe yarar? Neden bilmemiz gerekir bunu? Gerçek hayatta kullanılıyor mu?'' gibi. Anlamadığınız kısımlar varsa ve ChatGPT’nin açıklamaları yeterli gelmezse internet dahil farklı kaynaklardan araştırıp, bilgilerin doğruluğunu sorgulamakta serbestsiniz. Konuyu doğru anlayıp anlamamanız puana etki edecektir. Kullandığınız kaynakları da belirtin!}

Hopfield Network diğer yapay sinir ağlarından farklı şekilde tepki veren özel bir yapay sinir ağıdır. Yakınsayan(converging) yinelenen süreç ile hesaplanır.
Input ve outputun boyuna ilişkin olan sadece bir kat nöronlara sahitptir ve input ile output aynı boyutta olması gerekir. Katmandaki nöron sayılarına göre kapasiteleri vardır. Fakat kapasitesi sınırlıdır. Hopfield ağı işlemi iki aşamadan oluşamaktadır: Depolama aşaması ve geri çağırma aşaması. Depolama aşamasında nesneler veya karakterler depolanır bu eğitim aşamasıdır. Bu depolama saklama, hatırlama ve yeniden çağırılma amacıyla yapılır. Öğrenme işlemi, ağın önceden tanımlanmış bir enerji fonksiyonuna göre gerçekleşir. Bu enerji fonksiyonu, ağın doğru bir şekilde öğrenmesi için hedef çıkış değerlerini tanımlar. Öğrenme işlemi tamamlandıktan sonra, ağa hatırlatma işlemi uygulanabilir. Hatırlatma işlemi, ağa daha önce öğrenilmiş verilerin sunulması ile gerçekleşir. Hatırlatma işleminde de enerji fonksiyonları kullanılır. Ağ, bu verileri hatırlar ve doğru çıkışları üretir. Hopfield ağları senkron modda da çalışabilirmiş. Asenkron modda, ağdaki her bir nöron kendi başına çalışır ve değerleri sadece kendisini etkileyen diğer nöronlardan alır. Senkron modda ise, tüm ağ aynı anda hesaplama yapar ve her bir nöronun değerleri tüm nöronlara aynı anda yayılır.Bildiğim kadarıyla, Hopfield'ın çalışması üzerine inşa edildikleri için Boltzmann Makineleri ve Deep Belief Networks anlatılmak istendiğinde çoğunlukla ders kitaplarında tanıtılıyor ve bahsediliyorlar. Ancak derin öğrenmenin mevcut durumuna kıyasla öğrenme sistemlerine o kadar farklı ve alternatif bir bakış açısı sunuyorlar ki, sırf bu yüzden bile anlamaya değerdir.  

 Kullanım alanları:

    * Şifreleme işlemlerinde
    * Karakter-Desen Eşleştirmede
    * Bozuk Şekillerin Yeniden Oluşturulmasında
    * El Yazı Tanımlama Sistemlerinde

    Kaynaklar: 

    \url{https://medium.com/@batincangurbuz/hopfield-a%C4%9F-modeli-hopfield-network-hn-ccf1548ca432}
    \url{https://www.javatpoint.com/artificial-neural-network-hopfield-network}\newline
    \url{https://towardsdatascience.com/hopfield-networks-are-useless-heres-why-you-should-learn-them-f0930ebeadcd}
    

\section{(Toplam 10 Puan) Boltzman Machine:}

\subsection{(2 Puan)} \textbf{ChatGPT’ye size Boltzman Machine ilgili detaylı bilgi vermesini isteyin. Sorduğunuz soruyu, ChatGPT'nin çıkartığı cevabı aşağı koyun. Bu cevapta anlamadığınız terimleri de ChatGPT’ye sorup, sorduğunuz soruları ve ChatGPT’nin verdiği cevapları da sırayla aşağı koyun.}

Soru: Bana Boltzman Machine ile ilgili detaylı bilgi verebilir misin?

Cevap: Boltzmann Machine, yapay sinir ağları sınıfından bir modeldir. Bu model, belirli bir veri kümesine dayalı olarak öğrenme yapabilen ve bu öğrenme sonucunda veri kümesiyle benzer örüntüler üretebilen bir algoritmadır. Boltzmann Machine, çeşitli uygulamalarda kullanılabilen bir modeldir ve özellikle sınıflandırma, modelleme, veri sıkıştırma ve veri işleme gibi alanlarda kullanılır.

Boltzmann Machine, enerji minimizasyonu prensibine dayanır. Bu prensibe göre, sistemin en düşük enerji durumuna ulaşması beklenir. Boltzmann Machine, birbirleriyle bağlantılı iki sinir katmanından oluşur. Bu katmanlardan biri, görünür katman olarak adlandırılırken, diğeri gizli katman olarak adlandırılır. Görünür katman, sisteme giren veriyi alırken, gizli katman, bu veriyi işleyerek bir sonuç üretir. Bu sonuç, tekrar görünür katmana geri gönderilir ve böylece bir geri besleme döngüsü oluşur.

Boltzmann Machine, enerji fonksiyonu kullanarak öğrenme yapar. Bu enerji fonksiyonu, ağın parametreleri olan ağırlıkları ve bias değerlerini kullanarak hesaplanır. Bu hesaplama, sistemin bir enerji seviyesi elde etmesini sağlar. Sistemin en düşük enerji seviyesine ulaşabilmesi için, enerji fonksiyonunun minimum değere ulaşması gerekmektedir. Bu minimum değer, verilen veri kümesi için elde edilir ve bu değer, modelin öğrenmesinin tamamlandığı anlamına gelir.

Boltzmann Machine'in en önemli özelliklerinden biri, öğrenme işleminin unsupervised (denetimsiz) olmasıdır. Yani, veri kümesindeki örneklerin sınıflandırılması veya etiketlenmesi gibi bir denetim mekanizması kullanılmaz. Bunun yerine, model, veri kümesinin içindeki örüntüleri kendi kendine keşfeder.

Sonuç olarak, Boltzmann Machine, öğrenme yapabilen ve veri kümesi içindeki örüntüleri kendi kendine keşfedebilen bir yapay sinir ağı modelidir. Bu model, unsupervised öğrenme yapabilmesi, veri işleme ve modelleme gibi birçok alanda kullanılabilmesi gibi avantajları nedeniyle popüler bir yapay sinir ağı modelidir.

Sorular:\newline
1-Boltzman machinedeki enerji minimizasyonu prensibi nedir?\newline
Cevap: Boltzmann Machine, enerji minimizasyonu prensibi üzerine kurulu bir yapay sinir ağıdır. Bu prensibe göre, Boltzmann Machine, sistemin mümkün olan en düşük enerji durumuna ulaşmak için çalışır.

Bir Boltzmann Machine'de, nöronlar arasındaki bağlantılar ağırlıklarla ifade edilir ve ağdaki her bir durumun bir enerji seviyesi vardır. Bu enerji seviyesi, ağdaki bağlantı ağırlıkları ve nöron aktivasyonları tarafından belirlenir.

Boltzmann Machine, enerji seviyesini minimize etmek için nöronların aktivasyonlarını değiştirir. Ağdaki her bir nöron, belirli bir aktivasyon seviyesine sahiptir ve bu seviyeler ağın enerji seviyesini belirler. Ağ, enerji seviyesini minimize etmek için nöron aktivasyonlarını değiştirerek en düşük enerji durumuna ulaşmaya çalışır.

Boltzmann Machine, enerji minimizasyonu prensibi sayesinde, öğrenme ve veri analizi gibi pek çok alanda kullanılabilir. Özellikle, çeşitli veri tiplerini modellemek ve karmaşık yapılar içindeki desenleri tanımak için yaygın olarak kullanılmaktadır.

2-Bias değeri nedir?\newline
Cevap: Bir yapay sinir ağında, bias, her bir nöronun çıktısına eklenen sabit bir değerdir. Bias değeri, nöronun aktivasyon eşiğini belirler ve nöronun girdileri ile çıktısı arasındaki ilişkiyi etkiler. Bias, yapay sinir ağının öğrenme sürecinde optimize edilen bir parametredir ve ağın performansını arttırmaya yardımcı olur.

\subsection{(8 Puan)} \textbf{ChatGPT’nin açıklamalarından ne anladığınızı buraya kendi kelimelerinizle özetleyin. Örneğin ``Boltzman Machine nedir? Ne işe yarar? Neden bilmemiz gerekir bunu? Gerçek hayatta kullanılıyor mu?'' gibi. Anlamadığınız kısımlar varsa ve ChatGPT’nin açıklamaları yeterli gelmezse internet dahil farklı kaynaklardan araştırıp, bilgilerin doğruluğunu sorgulamakta serbestsiniz. Konuyu doğru anlayıp anlamamanız puana etki edecektir. Kullandığınız kaynakları da belirtin!}

Boltzman Machine sınıflandırma, modelleme, veri sıkıştırma ve veri işleme gibi alanlarda kullanılan bir yapay ağ sinir modelidir. 

Boltzmann Makinesi iki katmanlı bir sinir ağından oluşur. Bu modelin ilk katmanı görünür ya da input layer, ikincisi ise hidden layer olarak adlandırılır. Bunlar düğüm adı verilen nöron benzeri birimlerden oluşur ve hesaplamalar burada gerçekleşir. Bu düğümler katmanlar arasında birbirine bağlıdır, ancak aynı katmandaki iki düğüm birbirine bağlı değildir. Bu nedenle katman içi iletişim yoktur ve dolayısıyla Boltzmann makinesindeki kısıtlamalardan biridir. Hesaplama yoluyla her düğüm girdiyi işler ve bu girdiyi iletip iletmeme konusunda rastgele kararlar verir. Veri girdi olarak verildiğinde, bu düğümler tüm parametreleri, örüntülerini ve aralarındaki korelasyonu kendi başlarına öğrenir ve verimli bir sistem oluşturur. Bu nedenle bir Boltzmann Makinesi, unsupervised modeli olarak da adlandırılır.

Öncelikle, rastgele bir giriş verisi düğümlere uygulanır ve ardından düğümlerdeki değerler belirli bir hesaplama yöntemiyle güncellenir. Bu hesaplama, tüm düğümlerin enerji fonksiyonunun hesaplanmasını içerir ve bu enerji fonksiyonu, her bir düğümün durumunun girdi verisine göre ne kadar uyumlu olduğunu belirler. Enerji fonksiyonu, ağırlıklar ve düğümlerin durumu arasındaki kombinasyonlara bağlıdır.

Boltzman Machine'nin birden farklı RBM gibi türleri vardır. Boltzmann Makineleri, çok sayıda niteliğe ve şu anda modern teknoloji çağında uygulanmakta olan çok sayıda kullanıma sahip oldukları için gelişmiş bir sinir ağı biçimi olarak düşünülebilir. Birçok varyasyonu vardır ve sürekli iyileştirmeler ve geliştirmeler hala keşfedilmeyi beklemektedir. Kullanıldıklarında büyük bir avantaj sağlarlar ve eğitimleri ile optimizasyonları için popülerdirler.

 Kaynaklar: 

    \url{https://analyticsindiamag.com/beginners-guide-to-boltzmann-machines/} \newline
    \url{https://medium.com/@batincangurbuz/boltzman-makinesi-boltzmann-machines-bm-ve-k%C4%B1s%C4%B1tlanm%C4%B1%C5%9F-boltzmann-makineleri-restricted-boltzmann-6f2e0f839b05}\newline
    \url{https://towardsdatascience.com/hopfield-networks-are-useless-heres-why-you-should-learn-them-f0930ebeadcd}

\section{(Toplam 10 Puan) Markov Assumption ve Markov Chain:}

\subsection{(2 Puan)} \textbf{ChatGPT’ye size Markov assumption ve Markov Chain ilgili detaylı bilgi vermesini isteyin. Sorduğunuz soruyu, ChatGPT'nin çıkartığı cevabı aşağı koyun. Bu cevapta anlamadığınız terimleri de ChatGPT’ye sorup, sorduğunuz soruları ve ChatGPT’nin verdiği cevapları da sırayla aşağı koyun.}

Soru: Bana Markov assumption ve Markov Chain ilgili detaylı bilgi verebilir misin?

Cevap: Markov Assumption, bir olayın gelecekteki durumunun sadece o anki durumuna bağlı olduğunu varsayar. Bu varsayıma göre, gelecekteki durumlar, yalnızca mevcut durumunun bir fonksiyonu olarak belirlenir ve geçmiş durumlar, gelecekteki durumların belirlenmesinde bir rol oynamaz.

Markov Chain (Markov Zinciri), bir sistemdeki durumların ve bu durumların birbirleriyle olan ilişkilerinin matematiksel bir modelidir. Markov Zinciri, Markov Assumption'a dayanır ve sistemin gelecekteki durumunun yalnızca mevcut durumuna bağlı olduğunu varsayar. Markov Zinciri, birçok uygulamada kullanılan önemli bir olasılık modelidir.

Markov Chain, bir dizi durumdan oluşur ve her bir durum, sistemin bir anlık durumunu temsil eder. Her bir durum, sistemin olası durumlarından birini temsil eder ve bu durumlar arasında geçişler, belirli olasılıklarla gerçekleşir. Bu geçiş olasılıkları, her bir durum için ayrı ayrı belirlenir.

Markov Chain'in matematiksel modeli, bir geçiş matrisi kullanarak tanımlanır. Bu matris, sistemin olası durumlarını ve bu durumlar arasındaki geçiş olasılıklarını gösterir. Geçiş matrisi, her bir durumun olası diğer durumlara geçiş olasılıklarını gösteren bir kare matristir. Matrisin i. satırı, i. durumunun diğer durumlara geçiş olasılıklarını gösterir. Bu matris, sistemin gelecekteki durumlarını tahmin etmek için kullanılır.

Markov Chain'in bir diğer önemli özelliği, durağanlık (stationarity) özelliğidir. Bu özellik, zincirin uzun vadeli davranışını belirler ve zincirin belli bir noktada belirli bir durumda kalması durumunda, uzun vadede zincirin dağılımının sabit kalacağını varsayar.

Markov Chain, birçok uygulamada kullanılan bir modeldir. Örneğin, makinelerin onarımında ve üretimde, finansal piyasalarda, rastgele hareket eden parçacıkların davranışını incelemekte ve nükleer fizikte kullanılır.

Sorular:\newline
1-Markov chain durağanlık özelliği tam olarak nedir ?\newline
Cevap: Markov zinciri durağanlık özelliği, zincirin belirli bir noktada belirli bir duruma ulaşması durumunda, zincirin bir sonraki adımda o durumda kalma olasılığının önceki adımlarla bağımsız olduğunu ifade eder. Başka bir deyişle, zincir zaman ilerledikçe durumlar arasındaki olasılıkların değişebilir, ancak belirli bir noktada zincirin durumu, bir sonraki adımda aynı durumda kalma olasılığı üzerinde herhangi bir etkiye sahip değildir. Durağanlık özelliği, Markov zincirleri için önemlidir, çünkü uzun vadeli davranışın analizinde kullanılabilir ve bu özellik sağlandığında, zincirin sonlu bir süre içinde duruma ulaşması beklenir.

2-Markov chain durağanlık özelliği tam olarak nedir ?\newline
Cevap: Geçiş matrisi, Markov zincirindeki her bir durumun diğer durumlara geçiş olasılıklarını gösteren bir matristir. Matrisin i. satırı, i. durumunun diğer durumlara geçiş olasılıklarını içerir. Geçiş matrisi, Markov zincirindeki tüm durumlar ve durumlar arasındaki geçiş olasılıkları hakkında tam bir bilgi sağlar.

\subsection{(8 Puan)} \textbf{ChatGPT’nin açıklamalarından ne anladığınızı buraya kendi kelimelerinizle özetleyin. Örneğin ``Markov assumption ve Markov Chain nedir? Ne işe yarar? Neden bilmemiz gerekir bunu? Gerçek hayatta kullanılıyor mu?'' gibi. Anlamadığınız kısımlar varsa ve ChatGPT’nin açıklamaları yeterli gelmezse internet dahil farklı kaynaklardan araştırıp, bilgilerin doğruluğunu sorgulamakta serbestsiniz. Konuyu doğru anlayıp anlamamanız puana etki edecektir. Kullandığınız kaynakları da belirtin!}

Markov assumption bir sistemin gelecekteki durumunun yalnızca mevcut durumuna bağlı olduğunu ve geçmiş durumlarına bağlı olmadığını varsayar. Bu varsayım genellikle konuşma, dil ve zaman serisi verileri gibi sıralı verilerin modellenmesinde kullanılır ve Gizli Markov Modelleri (HMM'ler) ve Tekrarlayan Sinir Ağları (RNN'ler) gibi birçok sinir ağı modelinin tasarımında temeldir. Bu varsayımı yaparak, bu modeller girdi verilerinin zamansal dinamiklerini etkili bir şekilde yakalayabilir ve geçmiş gözlemlerin geçmişine dayanarak doğru tahminler yapabilir.


Markov Zincirleri, dinamik ve stokastik sistemlerin analizinde ve özellikle bir sistemin zaman boyunca içinde bulunabileceği farklı durumlar arasında yaptığı hareketlerin incelenmesinde kullanılan modellerdir. Genel olarak, Markov Zincirleri kavramsal olarak sezgiseldir ve herhangi bir gelişmiş istatistiksel veya matematiksel kavram kullanılmadan uygulanabilmeleri erişilebilirdir.

Markov zinciri bir stokastik süreçtir, ancak Markov zincirinin "hafızasız" olması gerektiği için genel bir stokastik süreçten farklıdır. Yani, gelecekteki eylemlerin (olasılığı) mevcut duruma yol açan adımlara bağlı değildir. Buna Markov özelliği denir. Markov zincirleri teorisi tam da pek çok "gündelik" süreç Markov özelliğini karşıladığı için önemli olsa da, Markov özelliğini karşılamayan pek çok yaygın stokastik özellik örneği vardır.

Markov zincirleri, rastgele süreçleri istatistiksel olarak modellemenin oldukça yaygın ve nispeten basit bir yoludur. Metin oluşturmadan finansal modellemeye kadar birçok farklı alanda kullanılmıştır. Fakat en çok kullanılan alanları ise metin oluşturma ve otomatik tamamlama uygulamalarıdır.


   Kaynaklar: 

    \url{https://medium.com/@batincangurbuz/markov-zinciri-markov-chain-mc-33cd8a61f6fa}
    \url{https://brilliant.org/wiki/markov-chains/k}\newline
    \url{https://towardsdatascience.com/introduction-to-markov-chains-50da3645a50d}

\section{(Toplam 20 Puan) Feed Forward:}
 
\begin{itemize}
    \item Forward propagation için, input olarak şu X matrisini verin (tensöre çevirmeyi unutmayın):\\
    $X = \begin{bmatrix}
        1 & 2 & 3\\
        4 & 5 & 6
        \end{bmatrix}$
    Satırlar veriler (sample'lar), kolonlar öznitelikler (feature'lar).
    \item Bir adet hidden layer olsun ve içinde tanh aktivasyon fonksiyonu olsun
    \item Hidden layer'da 50 nöron olsun
    \item Bir adet output layer olsun, tek nöronu olsun ve içinde sigmoid aktivasyon fonksiyonu olsun
\end{itemize}

Tanh fonksiyonu:\\
$f(x) = \frac{exp(x) - exp(-x)}{exp(x) + exp(-x)}$
\vspace{.2in}

Sigmoid fonksiyonu:\\
$f(x) = \frac{1}{1 + exp(-x)}$

\vspace{.2in}
 \textbf{Pytorch kütüphanesi ile, ama kütüphanenin hazır aktivasyon fonksiyonlarını kullanmadan, formülünü verdiğim iki aktivasyon fonksiyonunun kodunu ikinci haftada yaptığımız gibi kendiniz yazarak bu yapay sinir ağını oluşturun ve aşağıdaki üç soruya cevap verin.}
 
\subsection{(10 Puan)} \textbf{Yukarıdaki yapay sinir ağını çalıştırmadan önce pytorch için Seed değerini 1 olarak set edin, kodu aşağıdaki kod bloğuna ve altına da sonucu yapıştırın:}

% Latex'de kod koyabilirsiniz python formatında. Aşağıdaki örnekleri silip içine kendi kodunuzu koyun
\begin{python}

import torch

torch.manual_seed(1)

X = torch.tensor([[1, 2, 3], [4, 5, 6]], dtype=torch.float)

W1 = torch.randn(3, 50)
b1 = torch.randn(1, 50)

W2 = torch.randn(50, 1)
b2 = torch.randn(1, 1)

def tanh_activation(x):
    return (torch.exp(x) - torch.exp(-x)) / (torch.exp(x) + torch.exp(-x))

def sigmoid_activation(x):
    return 1 / (1 + torch.exp(-x))

hidden_layer = tanh_activation(torch.matmul(X, W1) + b1)
output_layer = sigmoid_activation(torch.matmul(hidden_layer, W2) + b2)

print(output_layer)

\end{python}

\textbf\\tensor([[0.0498],
        [0.0075]])


\subsection{(5 Puan)} \textbf{Yukarıdaki yapay sinir ağını çalıştırmadan önce Seed değerini öğrenci numaranız olarak değiştirip, kodu aşağıdaki kod bloğuna ve altına da sonucu yapıştırın:}

\begin{python}
import torch

torch.manual_seed(210401006)

X = torch.tensor([[1, 2, 3], [4, 5, 6]], dtype=torch.float)

W1 = torch.randn(3, 50)
b1 = torch.randn(1, 50)

W2 = torch.randn(50, 1)
b2 = torch.randn(1, 1)

def tanh_activation(x):
    return (torch.exp(x) - torch.exp(-x)) / (torch.exp(x) + torch.exp(-x))

def sigmoid_activation(x):
    return 1 / (1 + torch.exp(-x))

hidden_layer = tanh_activation(torch.matmul(X, W1) + b1)
output_layer = sigmoid_activation(torch.matmul(hidden_layer, W2) + b2)

print(output_layer)
\end{python}

\textbf tensor([[0.9988],
        [0.9966]])

\subsection{(5 Puan)} \textbf{Kodlarınızın ve sonuçlarınızın olduğu jupyter notebook'un Github repository'sindeki linkini aşağıdaki url kısmının içine yapıştırın. İlk sayfada belirttiğim gün ve saate kadar halka açık (public) olmasın:}
% size ait Github olmak zorunda, bu vize için ayrı bir github repository'si açıp notebook'u onun içine koyun. Kendine ait olmayıp da arkadaşının notebook'unun linkini paylaşanlar 0 alacak.

\url{https://github.com/aliyetgin/feed_forward}

\section{(Toplam 40 Puan) Multilayer Perceptron (MLP):} 
\textbf{Bu bölümdeki sorularda benim vize ile beraber paylaştığım Prensesi İyileştir (Cure The Princess) Veri Seti parçaları kullanılacak. Hikaye şöyle (soruyu çözmek için hikaye kısmını okumak zorunda değilsiniz):} 

``Bir zamanlar, çok uzaklarda bir ülkede, ağır bir hastalığa yakalanmış bir prenses yaşarmış. Ülkenin kralı ve kraliçesi onu iyileştirmek için ellerinden gelen her şeyi yapmışlar, ancak denedikleri hiçbir çare işe yaramamış.

Yerel bir grup köylü, herhangi bir hastalığı iyileştirmek için gücü olduğu söylenen bir dizi sihirli malzemeden bahsederek kral ve kraliçeye yaklaşmış. Ancak, köylüler kral ile kraliçeyi, bu malzemelerin etkilerinin patlayıcı olabileceği ve son zamanlarda yaşanan kuraklıklar nedeniyle bu malzemelerden sadece birkaçının herhangi bir zamanda bulunabileceği konusunda uyarmışlar. Ayrıca, sadece deneyimli bir simyacı bu özelliklere sahip patlayıcı ve az bulunan malzemelerin belirli bir kombinasyonunun prensesi iyileştireceğini belirleyebilecekmiş.

Kral ve kraliçe kızlarını kurtarmak için umutsuzlar, bu yüzden ülkedeki en iyi simyacıyı bulmak için yola çıkmışlar. Dağları tepeleri aşmışlar ve nihayet "Yapay Sinir Ağları Uzmanı" olarak bilinen yeni bir sihirli sanatın ustası olarak ün yapmış bir simyacı bulmuşlar.

Simyacı önce köylülerin iddialarını ve her bir malzemenin alınan miktarlarını, ayrıca iyileşmeye yol açıp açmadığını incelemiş. Simyacı biliyormuş ki bu prensesi iyileştirmek için tek bir şansı varmış ve bunu doğru yapmak zorundaymış. (Original source: \url{https://www.kaggle.com/datasets/unmoved/cure-the-princess})

(Buradan itibaren ChatGPT ve Dr. Ulya Bayram'a ait hikayenin devamı)

Simyacı, büyülü bileşenlerin farklı kombinasyonlarını analiz etmek ve denemek için günler harcamış. Sonunda birkaç denemenin ardından prensesi iyileştirecek çeşitli karışım kombinasyonları bulmuş ve bunları bir veri setinde toplamış. Daha sonra bu veri setini eğitim, validasyon ve test setleri olarak üç parçaya ayırmış ve bunun üzerinde bir yapay sinir ağı eğiterek kendi yöntemi ile prensesi iyileştirme ihtimalini hesaplamış ve ikna olunca kral ve kraliçeye haber vermiş. Heyecanlı ve umutlu olan kral ve kraliçe, simyacının prensese hazırladığı ilacı vermesine izin vermiş ve ilaç işe yaramış ve prenses hastalığından kurtulmuş.

Kral ve kraliçe, kızlarının hayatını kurtardığı için simyacıya krallıkta kalması ve çalışmalarına devam etmesi için büyük bir araştırma bütçesi ve çok sayıda GPU'su olan bir server vermiş. İyileşen prenses de kendisini iyileştiren yöntemleri öğrenmeye merak salıp, krallıktaki üniversitenin bilgisayar mühendisliği bölümüne girmiş ve mezun olur olmaz da simyacının yanında, onun araştırma grubunda çalışmaya başlamış. Uzun yıllar birlikte krallıktaki insanlara, hayvanlara ve doğaya faydalı olacak yazılımlar geliştirmişler, ve simyacı emekli olduğunda prenses hem araştırma grubunun hem de krallığın lideri olarak hayatına devam etmiş.

Prenses, kendisini iyileştiren veri setini de, gelecekte onların izinden gidecek bilgisayar mühendisi prensler ve prensesler başkalarına faydalı olabilecek yapay sinir ağları oluşturmayı öğrensinler diye halka açmış ve sınavlarda kullanılmasını salık vermiş.''

\textbf{İki hidden layer'lı bir Multilayer Perceptron (MLP) oluşturun beşinci ve altıncı haftalarda yaptığımız gibi. Hazır aktivasyon fonksiyonlarını kullanmak serbest. İlk hidden layer'da 100, ikinci hidden layer'da 50 nöron olsun. Hidden layer'larda ReLU, output layer'da sigmoid aktivasyonu olsun.}

\textbf{Output layer'da kaç nöron olacağını veri setinden bakıp bulacaksınız. Elbette bu veriye uygun Cross Entropy loss yöntemini uygulayacaksınız. Optimizasyon için Stochastic Gradient Descent yeterli. Epoch sayınızı ve learning rate'i validasyon seti üzerinde denemeler yaparak (loss'lara overfit var mı diye bakarak) kendiniz belirleyeceksiniz. Batch size'ı 16 seçebilirsiniz.}

\subsection{(10 Puan)} \textbf{Bu MLP'nin pytorch ile yazılmış class'ının kodunu aşağı kod bloğuna yapıştırın:}

\begin{python}
import torch
import torch.nn as nn
import torch.nn.functional as F

class MLP(nn.Module):
    def __init__(self, num_input_feats, num_hidden_neuron_1, num_hidden_neuron_2, num_classes):
        super(MLP, self).__init__()
        self.hidden_layer_1 = nn.Linear(num_input_feats, num_hidden_neuron_1)
        self.hidden_layer_2 = nn.Linear(num_hidden_neuron_1, num_hidden_neuron_2)
        self.output_layer = nn.Linear(num_hidden_neuron_2, num_classes)
        
    def forward(self, x):
        x = x.view(x.size(0), -1)
        hidden_res_1 = F.relu(self.hidden_layer_1(x))
        hidden_res_2 = F.relu(self.hidden_layer_2(hidden_res_1))
        output = F.sigmoid(self.output_layer(hidden_res_2))
        return output
\end{python}

\subsection{(10 Puan)} \textbf{SEED=öğrenci numaranız set ettikten sonra altıncı haftada yazdığımız gibi training batch'lerinden eğitim loss'ları, validation batch'lerinden validasyon loss değerlerini hesaplayan kodu aşağıdaki kod bloğuna yapıştırın ve çıkan figürü de alta ekleyin.}

\begin{python}
import numpy as np
import pandas as pd
!pip install torchtext==0.10.0

import torch

SEED = 210401006
torch.manual_seed(SEED)

from torchtext.legacy import data, datasets
import random
import nltk

nltk.download('punkt')
nltk.download('averaged_perceptron_tagger')
nltk.download('brown')
nltk.download('webtext')

def load_dataset(sentence_length=50, batch_size=32, seed=SEED):

  TEXT = data.Field(sequential=True,
                    tokenize=nltk.word_tokenize,
                    lower=True,
                    include_lengths=True,
                    batch_first=True,
                    fix_length=sentence_length)
  LABEL = data.LabelField(dtype=torch.float)
  
  train_df = pd.read_csv('/content/cure_the_princess_train.csv') 
  test_df = pd.read_csv('/content/cure_the_princess_test.csv')
  val_df = pd.read_csv('/content/cure_the_princess_val.csv')


  train_examples = train_df.to_dict('records')
  test_examples = test_df.to_dict('records')
  val_examples = val_df.to_dict('records')


  train_data = data.Dataset(examples=train_examples, fields={'text': ('text', TEXT), 'label': ('label', LABEL)})
  test_data = data.Dataset(examples=test_examples, fields={'text': ('text', TEXT), 'label': ('label', LABEL)})
  val_data = data.Dataset(examples=val_examples, fields={'text': ('text', TEXT), 'label': ('label', LABEL)})


  TEXT.build_vocab(train_data)
  LABEL.build_vocab(train_data)


  train_iter, test_iter = data.BucketIterator.splits((train_data, test_data),
                                                      batch_size=batch_size, 
                                                      sort_key=lambda x: len(x.text),
                                                      repeat=False, shuffle=True)
  val_iter = data.BucketIterator(dataset=val_data,
                                  batch_size=batch_size, 
                                  sort_key=lambda x: len(x.text),
                                  repeat=False, shuffle=True)

  vocab_size = len(TEXT.vocab)

  print(f"Data loading is completed. Sentence length: {sentence_length}, Batch size: {batch_size}, and seed: {seed}")

  return TEXT, vocab_size, train_iter, val_iter, test_iter
import torch
import torch.nn as nn
import torch.nn.functional as F

class MLP(nn.Module):
    def __init__(self, num_input_feats, num_hidden_neuron_1, num_hidden_neuron_2, num_classes):
        super(MLP, self).__init__()
        self.hidden_layer_1 = nn.Linear(num_input_feats, num_hidden_neuron_1)
        self.hidden_layer_2 = nn.Linear(num_hidden_neuron_1, num_hidden_neuron_2)
        self.output_layer = nn.Linear(num_hidden_neuron_2, num_classes)
        
    def forward(self, x):
        x = x.view(x.size(0), -1)
        hidden_res_1 = F.relu(self.hidden_layer_1(x))
        hidden_res_2 = F.relu(self.hidden_layer_2(hidden_res_1))
        output = F.sigmoid(self.output_layer(hidden_res_2))
        return output

    import torch.optim as optim


TEXT, vocab_size, train_iter, val_iter, test_iter = load_dataset(sentence_length=50, batch_size=16, seed=SEED)

model = MLP(vocab_size, 64, 32, 1)

criterion = nn.BCELoss()

optimizer = optim.SGD(model.parameters(), lr=0.01)

num_epochs = 10
best_valid_loss = float('inf')

for epoch in range(num_epochs):
    train_loss = 0.0
    valid_loss = 0.0
    model.train()
    
    for batch in train_iter:
        optimizer.zero_grad()
        text, text_lengths = batch.text
        labels = batch.label.unsqueeze(1)
        output = model(text)
        loss = criterion(output, labels)
        loss.backward()
        optimizer.step()
        train_loss += loss.item() * len(batch)
    
    model.eval()
    
    with torch.no_grad():
        for batch in val_iter:
            text, text_lengths = batch.text
            labels = batch.label.unsqueeze(1)
            output = model(text)
            loss = criterion(output, labels)
            valid_loss += loss.item() * len(batch)
    
    train_loss /= len(train_iter.dataset)
    valid_loss /= len(val_iter.dataset)
    
    if valid_loss < best_valid_loss:
        best_valid_loss = valid_loss
        torch.save(model.state_dict(), 'best_model.pt')
    
    print(f'Epoch: {epoch+1:02}, Train Loss: {train_loss:.3f}, Val. Loss: {valid_loss:.3f}')



\end{python}

% Figure aşağıda comment içindeki kısımdaki gibi eklenir.
\begin{comment}
\begin{figure}[ht!]
    \centering
    \includegraphics[width=0.75\textwidth]{mypicturehere.png}
    \caption{Buraya açıklama yazın}
    \label{fig:my_pic}
\end{figure}
\end{comment}

\subsection{(10 Puan)} \textbf{SEED=öğrenci numaranız set ettikten sonra altıncı haftada ödev olarak verdiğim gibi earlystopping'deki en iyi modeli kullanarak, Prensesi İyileştir test setinden accuracy, F1, precision ve recall değerlerini hesaplayan kodu yazın ve sonucu da aşağı yapıştırın. \%80'den fazla başarı bekliyorum test setinden. Daha düşükse başarı oranınız, nerede hata yaptığınızı bulmaya çalışın. \%90'dan fazla başarı almak mümkün (ben denedim).}

\begin{python}
kod_buraya = None
if kod_buraya:
    devam_ise_buraya = 0

print(devam_ise_buraya)
\end{python}

Sonuçlar buraya

\subsection{(5 Puan)} \textbf{Tüm kodların CPU'da çalışması ne kadar sürüyor hesaplayın. Sonra to device yöntemini kullanarak modeli ve verileri GPU'ya atıp kodu bir de böyle çalıştırın ve ne kadar sürdüğünü hesaplayın. Süreleri aşağıdaki tabloya koyun. GPU için Google Colab ya da Kaggle'ı kullanabilirsiniz, iki ortam da her hafta saatlerce GPU hakkı veriyor.}

\begin{table}[ht!]
    \centering
    \caption{Buraya bir açıklama yazın}
    \begin{tabular}{c|c}
        Ortam & Süre (saniye) \\\hline
        CPU & kaç? \\
        GPU & kaç?\\
    \end{tabular}
    \label{tab:my_table}
\end{table}
\newline
\subsection{(3 Puan)} \textbf{Modelin eğitim setine overfit etmesi için elinizden geldiği kadar kodu gereken şekilde değiştirin, validasyon loss'unun açıkça yükselmeye başladığı, training ve validation loss'ları içeren figürü aşağı koyun ve overfit için yaptığınız değişiklikleri aşağı yazın. Overfit, tam bir çanak gibi olmalı ve yükselmeli. Ona göre parametrelerle oynayın.}

Cevaplar buraya

% Figür aşağı
\begin{comment}
\begin{figure}[ht!]
    \centering
    \includegraphics[width=0.75\textwidth]{mypicturehere.png}
    \caption{Buraya açıklama yazın}
    \label{fig:my_pic}
\end{figure}
\end{comment}

\subsection{(2 Puan)} \textbf{Beşinci soruya ait tüm kodların ve cevapların olduğu jupyter notebook'un Github linkini aşağıdaki url'e koyun.}

\url{https://github.com/aliyetgin/cure_the_princess}

\section{(Toplam 10 Puan)} \textbf{Bir önceki sorudaki Prensesi İyileştir problemindeki yapay sinir ağınıza seçtiğiniz herhangi iki farklı regülarizasyon yöntemi ekleyin ve aşağıdaki soruları cevaplayın.} 

\subsection{(2 puan)} \textbf{Kodlarda regülarizasyon eklediğiniz kısımları aşağı koyun:} 

\begin{python}
kod_buraya = None
if kod_buraya:
    devam_ise_buraya = 0

print(devam_ise_buraya)
\end{python}

\subsection{(2 puan)} \textbf{Test setinden yeni accuracy, F1, precision ve recall değerlerini hesaplayıp aşağı koyun:}

Sonuçlar buraya.

\subsection{(5 puan)} \textbf{Regülarizasyon yöntemi seçimlerinizin sebeplerini ve sonuçlara etkisini yorumlayın:}

Yorumlar buraya.

\subsection{(1 puan)} \textbf{Sonucun github linkini  aşağıya koyun:}

\url{www.benimgithublinkim2.com}

\end{document}
